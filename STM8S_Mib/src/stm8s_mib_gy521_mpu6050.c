/**
 ******************************************************************************
 * @file stm8s_mib_gy30_bh1750.c
 * @brief
 * @author MYMEDIA Co., Ltd.
 * @version V1.0.0
 * @date 2023.1.6
 ******************************************************************************
 */
#include "stm8s.h"
#include "stm8s_mib_i2c.h"
#include "stm8s_mib.h"
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
#define MPU6050_ADDR 0xD0
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void MPU6050_Init(void);
void MPU6050_ReadAll(int16_t *accel, int16_t *gyro);
uint8_t MPU6050_ReadReg(uint8_t reg);
void MPU6050_ReadAccel(int16_t *ax, int16_t *ay, int16_t *az);
uint8_t MPU6050_ResetAndInit(void);
void I2C_Bus_Recovery(void);
void MPU6050_WriteReg(uint8_t reg, uint8_t data);
uint8_t MPU6050_DiagnoseInit(void);
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/*

  MPU-6050은 3축 가속도계와 3축 자이로스코프가 결합된 6축 센서입니다.
  STM8S103에서 이 센서를 제어하려면 $I^2C$ 통신을 사용하며,
  센서가 처음 전원이 켜졌을 때 'Sleep 모드' 상태라는 점을 기억해야 합니다.
  이를 깨워주는(Wake-up) 과정이 필수입니다.
  1. MPU-6050 핵심 레지스터 정의
    레지스터 이름	주소	설명
    WHO_AM_I	0x75	센서 확인용 (기본값: 0x68)
    PWR_MGMT_1	0x6B	전원 관리 (기본값 0x40 - Sleep 상태)
    ACCEL_XOUT_H	0x3B	가속도 데이터 시작 주소
    GYRO_XOUT_H	0x43	자이로 데이터 시작 주소

  MPU-6050의 $I^2C$ 7비트 주소는 $0x68$이며, 8비트로 변환하면 **Write: $0xD0$, Read: $0xD1$**입니다.

   코드 활용 팁데이터 해석 (MSB/LSB):MPU-6050의 데이터는 16비트이며,
   레지스터에는 상위 8비트(High)와 하위 8비트(Low)로 나누어 저장됩니다.
   (buf[0] << 8) | buf[1]와 같이 비트 시프트 연산을 통해
   하나의 int16_t 정수로 합쳐야 완전한 값을 얻을 수 있습니다.
   WHO_AM_I 테스트:통신이 잘 되는지 확인하려면 MPU6050_ReadReg(0x75)를 호출해 보세요.
   0x68이 돌아온다면 I2C 통신과 센서 전원이 모두 정상인 상태입니다.
   범위 설정 (Scaling):ACCEL_CONFIG(0x1C) 레지스터에 0x00을 쓰면 ±2g 모드가 됩니다.
   이때 읽어온 정수값을 16384로 나누면 우리가 아는 $g$ 단위의 가속도가 됩니다.


   주소(Hex)	레지스터 이름	설명
  0x19	SMPLRT_DIV	샘플링 속도를 결정 (Sample Rate = 8kHz / (1 + DIV))
  0x1B	GYRO_CONFIG	자이로스코프 측정 범위 설정 (±250, ±500, ±1000, ±2000 °/s)
  0x1C	ACCEL_CONFIG	가속도계 측정 범위 설정 (±2g, ±4g, ±8g, ±16g)
  0x3B ~ 0x40	ACCEL_X/Y/Z OUT	3축 가속도 데이터 (각 축당 High/Low 2바이트씩 총 6바이트)
  0x41 ~ 0x42	TEMP_OUT	내부 온도 데이터
  0x43 ~ 0x48	GYRO_X/Y/Z OUT	3축 자이로 데이터 (각 축당 High/Low 2바이트씩 총 6바이트)
  0x6B	PWR_MGMT_1	전원 관리. **기본값이 Sleep 모드(0x40)**이므로 반드시 0x00을 써서 깨워야 함
  0x75	WHO_AM_I	장치 식별 번호. 정상적이라면 0x68 값을 반환


*/
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void MPU6050_Init(void)
{
  // 1. PWR_MGMT_1 레지스터를 0으로 설정하여 Sleep 모드 해제
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x6B);
  I2C_WriteByte(0x00); // Internal 8MHz oscillator 사용 및 Wake-up
  I2C_Stop();

  // 2. 가속도계 설정 (+/- 2g)
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x1C);
  I2C_WriteByte(0x00);
  I2C_Stop();

  // 3. 자이로스코프 설정 (+/- 250 deg/s)
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x1B);
  I2C_WriteByte(0x00);
  I2C_Stop();
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/*
  가속도(6바이트), 온도(2바이트), 자이로(6바이트) 총 14바이트를 한 번에 읽는 것이 가장 효율적입니다.
*/
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void MPU6050_ReadAll(int16_t *accel, int16_t *gyro)
{
  uint8_t buffer[14];
  int i;

  // 데이터 시작 주소(0x3B) 지정
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x3B);

  // 읽기 모드로 전환하여 14바이트 연속 읽기
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR | 0x01);

  for (i = 0; i < 14; i++)
  {
    if (i == 13)
    {
      I2C->CR2 &= ~0x04; // NACK
      I2C_Stop();
    }
    while (!(I2C->SR1 & 0x40))
      ;
    buffer[i] = I2C->DR;
  }
  I2C->CR2 |= 0x04; // ACK 복구

  // 가속도 데이터 조합
  accel[0] = (buffer[0] << 8) | buffer[1]; // X
  accel[1] = (buffer[2] << 8) | buffer[3]; // Y
  accel[2] = (buffer[4] << 8) | buffer[5]; // Z

  // 자이로 데이터 조합 (중간의 buffer[6,7]은 온도 데이터임)
  gyro[0] = (buffer[8] << 8) | buffer[9];   // X
  gyro[1] = (buffer[10] << 8) | buffer[11]; // Y
  gyro[2] = (buffer[12] << 8) | buffer[13]; // Z
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief 특정 레지스터 1바이트 읽기
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t MPU6050_ReadReg(uint8_t reg)
{
  uint8_t val;
  mib_printf(" MPU6050 MPU6050_ReadReg\r\n");
  I2C_Start();
  mib_printf(" MPU6050 1\r\n");
  I2C_SendAddress(MPU6050_ADDR); // Write 모드로 주소 전송
  mib_printf(" MPU6050 2\r\n");
  I2C_WriteByte(reg);            // 읽고 싶은 레지스터 주소 전송

  mib_printf(" MPU6050 3\r\n");
  I2C_Start();                          // Re-start
  mib_printf(" MPU6050 4\r\n");
  I2C_SendAddress(MPU6050_ADDR | 0x01); // Read 모드로 전환

  mib_printf(" MPU6050 5\r\n");
  // 1바이트 읽기 시 NACK 및 STOP 처리
  I2C->CR2 &= ~0x04; // NACK
  (void)I2C->SR3;    // ADDR 플래그 클리어
  I2C->CR2 |= 0x02;  // STOP

  while (!(I2C->SR1 & 0x40))
    ; // RXNE 대기
  val = I2C->DR;

  I2C->CR2 |= 0x04; // ACK 복구
  return val;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief 가속도 데이터(6바이트) 연속 읽기 예시
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void MPU6050_ReadAccel(int16_t *ax, int16_t *ay, int16_t *az)
{
  uint8_t buf[6];
  int i;

  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x3B); // 가속도 데이터 시작 주소 (ACCEL_XOUT_H)

  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR | 0x01);

  // 6바이트 연속 읽기
  for (i = 0; i < 6; i++)
  {
    if (i == 5)
    {
      I2C->CR2 &= ~0x04; // 마지막 바이트 전 NACK
      I2C_Stop();
    }
    while (!(I2C->SR1 & 0x40))
      ;
    buf[i] = I2C->DR;
  }
  I2C->CR2 |= 0x04; // ACK 복구

  // MSB(High)와 LSB(Low) 결합
  *ax = (int16_t)((buf[0] << 8) | buf[1]);
  *ay = (int16_t)((buf[2] << 8) | buf[3]);
  *az = (int16_t)((buf[4] << 8) | buf[5]);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief I2C 버스가 멈췄을 때(SDA가 Low로 고정될 때) 강제로 해제하는 함수
 * PB4(SCL)를 일반 GPIO로 전환하여 9번 클럭을 생성합니다.
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void I2C_Bus_Recovery(void)
{
  uint8_t i;
  volatile uint16_t d;
  I2C->CR1 &= ~0x01; // I2C 비활성화 (PE=0)

  // SCL(PB4)을 출력 모드로 전환
  GPIOB->DDR |= GPIO_PIN_4;
  GPIOB->CR1 |= GPIO_PIN_4; // Push-pull

  // 9번의 클럭 펄스를 생성하여 슬레이브의 데이터 라인을 Release 시킴
  for (i = 0; i < 9; i++)
  {
    GPIOB->ODR ^= GPIO_PIN_4;
    for (d = 0; d < 100; d++)
      ;
    GPIOB->ODR ^= GPIO_PIN_4;
    for (d = 0; d < 100; d++)
      ;
  }

  I2C_Config(); // 기존 I2C 설정 함수 재호출
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief MPU-6050을 하드웨어적으로 초기 상태로 되돌리고 재설정함
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t MPU6050_ResetAndInit(void)
{
  uint8_t who;
  volatile uint32_t i;
  // 1. I2C 버스 복구 시도
  I2C_Bus_Recovery();

  mib_printf(" MPU6050 Reset and Init...\r\n");
  // 2. 장치 소프트 리셋 (PWR_MGMT_1의 DEVICE_RESET 비트 세팅)
  // 이 명령을 내리면 모든 레지스터가 기본값으로 돌아갑니다.
  I2C_Start();
  mib_printf(" MPU6050 1\r\n");
  I2C_SendAddress(MPU6050_ADDR);
  mib_printf(" MPU6050 2\r\n");
  I2C_WriteByte(0x6B);
  mib_printf(" MPU6050 3\r\n");
  I2C_WriteByte(0x80); // DEVICE_RESET = 1
  mib_printf(" MPU6050 4\r\n");
  I2C_Stop();
  mib_printf(" MPU6050 5\r\n");

  // 리셋 후 센서가 안정화될 때까지 대기 (약 100ms)
  for (i = 0; i < 200000; i++)
    ;

  // 3. WHO_AM_I 확인 (통신 연결 테스트)
  who = MPU6050_ReadReg(0x75);
  mib_printf(" MPU6050 Reg[0x%02X] = 0x%02X\r\n", 0x75, (uint16_t)who);
  if (who != 0x68)
  {
    return 0; // 초기화 실패 (센서 응답 없음)
  }

  // 4. 센서 깨우기 (Sleep 모드 해제)
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x6B);
  I2C_WriteByte(0x00); // Sleep=0, 내장 클럭 사용
  I2C_Stop();

  // 5. 추가 설정 (샘플 속도, 필터 등)
  I2C_Start();
  I2C_SendAddress(MPU6050_ADDR);
  I2C_WriteByte(0x1A); // CONFIG 레지스터
  I2C_WriteByte(0x03); // 가속도/자이로 필터 설정 (안정적인 데이터용)
  I2C_Stop();

  return 1; // 초기화 성공
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief I2C 슬레이브 장치의 특정 레지스터에 1바이트를 기록합니다.
 * @param reg 읽고 싶은 레지스터 주소
 * @param data 기록할 데이터 값
 */
void MPU6050_WriteReg(uint8_t reg, uint8_t data) 
{
  mib_printf(" MPU6050 MPU6050_WriteReg...\r\n");
  // 1. Start Condition 생성
  I2C->CR2 |= 0x01;           // START = 1
  while (!(I2C->SR1 & 0x01)); // SB(Start Bit) 플래그 대기

  mib_printf(" MPU6050 2\r\n");
  // 2. 슬레이브 주소 전송 (Write 모드)
  // MPU6050_ADDR은 0xD0 (0x68 << 1)로 정의되어 있어야 합니다.
  I2C->DR = MPU6050_ADDR;     
  while (!(I2C->SR1 & 0x02)); // ADDR(Address sent) 플래그 대기
  (void)I2C->SR3;             // SR3를 읽어 ADDR 플래그 클리어 (필수)

  mib_printf(" MPU6050 3\r\n");
  // 3. 대상 레지스터 주소 전송
  I2C->DR = reg;
  while (!(I2C->SR1 & 0x80)); // TXE(Transmit Empty) 플래그 대기

  mib_printf(" MPU6050 4\r\n");
  // 4. 데이터 바이트 전송
  I2C->DR = data;
  while (!(I2C->SR1 & 0x80)); // TXE 플래그 대기
  while (!(I2C->SR1 & 0x04)); // BTF(Byte Transfer Finished) 대기 (전송 완료 확인)

  mib_printf(" MPU6050 5\r\n");
  // 5. Stop Condition 생성
  I2C->CR2 |= 0x02;           // STOP = 1
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// 에러 코드 정의
#define INIT_OK         0
#define ERR_WHO_AM_I    1
#define ERR_RESET       2
#define ERR_WAKEUP      3
#define ERR_CONFIG      4
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief MPU-6050 초기화 진단 함수
 * @return 0이면 성공, 나머지는 실패한 단계의 번호
 */
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t MPU6050_DiagnoseInit(void) 
{
  uint8_t checkData = 0;
  volatile uint32_t i;

  mib_printf(" MPU6050 MPU6050_DiagnoseInit...\r\n");
  // STEP 1: 장치 연결 확인 (WHO_AM_I)
  checkData = MPU6050_ReadReg(0x75);
  if (checkData != 0x68) return ERR_WHO_AM_I; // 연결 안 됨 또는 주소 틀림

  mib_printf(" dMPU6050 2\r\n");
  // STEP 2: 소프트웨어 리셋
  // PWR_MGMT_1(0x6B)의 7번 비트를 1로 설정
  // MPU6050_WriteReg(0x6B, 0x80); 
  for (i = 0; i < 100000; i++); // 리셋 후 안정화 대기

  mib_printf(" dMPU6050 3\r\n");
  // STEP 3: 슬립 모드 해제 및 클럭 소스 설정
  // 0x00을 써서 Sleep 비트를 끄고 내부 8MHz 오실레이터 사용
  MPU6050_WriteReg(0x6B, 0x00); 
  checkData = MPU6050_ReadReg(0x6B);
  if (checkData != 0x00) return ERR_WAKEUP; // 잠에서 깨어나지 못함

  mib_printf(" dMPU6050 4\r\n");
  // STEP 4: 가속도 및 자이로 범위 설정
  // ACCEL_CONFIG(0x1C) -> ±2g 설정 (0x00)
  MPU6050_WriteReg(0x1C, 0x00); 
  // GYRO_CONFIG(0x1B) -> ±250°/s 설정 (0x00)
  MPU6050_WriteReg(0x1B, 0x00); 
  
  checkData = MPU6050_ReadReg(0x1C);
  if (checkData != 0x00) return ERR_CONFIG; // 설정값 기록 실패

  mib_printf(" dMPU6050 5\r\n");
  // STEP 5: DLPF (Low Pass Filter) 설정
  // CONFIG(0x1A) -> 약 44Hz 필터 적용 (0x03)
  MPU6050_WriteReg(0x1A, 0x03);

  return INIT_OK; // 모든 과정 통과!
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////