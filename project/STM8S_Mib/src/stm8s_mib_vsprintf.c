//
//
//  file name : stm8s_mib_vsprintf.c
//  designed by yooaroma  // yooaroma 2018-01-16 PM 10:27:55
//	date : 2006. 4. 11.
//
//
/* Includes */
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#include <stdarg.h>
#include "stm8s.h"
// #include <stdint.h>
// #include <stm8s.h>
// #include <stdarg.h>
#include <ctype.h>
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// 1. 숫자를 문자열로 변환하는 핵심 엔진 (long 지원)
static char *format_num(char *str, uint32_t num, int base, int width, char pad, int upper)
{
    char buf[11];
    int i = 0;
    const char *hex_chars = upper ? "0123456789ABCDEF" : "0123456789abcdef";

    // 숫자 추출
    if (num == 0)
        buf[i++] = '0';
    else
    {
        while (num > 0)
        {
            buf[i++] = hex_chars[num % base];
            num /= base;
        }
    }

    // 패딩(Padding) 처리
    while (i < width)
        buf[i++] = pad;

    // 역순으로 저장된 문자를 출력 버퍼에 기록
    while (i > 0)
        *str++ = buf[--i];

    return str;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// 2. 메인 vsprintf 함수 (if-else 구조로 컴파일러 패닉 방지)
int simple_vsprintf(char *buf, const char *fmt, va_list args)
{
    char *p = buf;
    int32_t val = 0;
    char pad = ' ';
    int width = 0;

    while (*fmt)
    {
        if (*fmt != '%')
        {
            *p++ = *fmt++;
            continue;
        }

        fmt++; // '%' 건너뜀

        // 플래그 처리 (예: %02d 에서 '0')
        pad = ' ';
        if (*fmt == '0')
        {
            pad = '0';
            fmt++;
        }

        // 너비 처리 (예: %02d 에서 '2')
        width = 0;
        while (*fmt >= '0' && *fmt <= '9')
        {
            width = width * 10 + (*fmt - '0');
            fmt++;
        }

        // 타입 처리
        if (*fmt == 'l')
        { // 32비트 long 처리 (%ld, %lx)
            fmt++;
            if (*fmt == 'd')
            {
                // int32_t val = va_arg(args, int32_t);
                val = va_arg(args, int32_t);
                if (val < 0)
                {
                    *p++ = '-';
                    val = -val;
                }
                p = format_num(p, (uint32_t)val, 10, width, pad, 0);
            }
            else if (*fmt == 'u')
            {
                p = format_num(p, va_arg(args, uint32_t), 10, width, pad, 0);
            }
            else if (*fmt == 'x' || *fmt == 'X')
            {
                p = format_num(p, va_arg(args, uint32_t), 16, width, pad, (*fmt == 'X'));
            }
        }
        else if (*fmt == 'd')
        { // 16비트 int
            // int16_t val = va_arg(args, int);
            val = va_arg(args, int);
            if (val < 0)
            {
                *p++ = '-';
                val = -val;
            }
            p = format_num(p, (uint32_t)val, 10, width, pad, 0);
        }
        else if (*fmt == 'u')
        { // 16비트 unsigned
            val = va_arg(args, unsigned int);
            p = format_num(p, (uint32_t)val, 10, width, pad, 0);
        }
        else if (*fmt == 'x' || *fmt == 'X')
        { // 16비트 hex
            val = va_arg(args, unsigned int);
            p = format_num(p, (uint32_t)val, 16, width, pad, (*fmt == 'X'));
        }
        else if (*fmt == 's')
        { // 문자열
            char *s = va_arg(args, char *);
            while (*s)
                *p++ = *s++;
        }
        else if (*fmt == 'c')
        { // 문자
            *p++ = (char)va_arg(args, int);
        }
        else
        { // %% 또는 기타
            *p++ = *fmt;
        }
        fmt++;
    }
    *p = '\0';
    return (int)(p - buf);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
extern void MibWriteDebugByte(uint8_t c);
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
/*
 * write formatted output to stdout immediately
 */
int mib_printf(char *format, ...)
{
    va_list ap;
    char buffer[96];
    char *v_pString;
    int rc;

    va_start(ap, format);
    rc = simple_vsprintf(buffer, format, ap);
    va_end(ap);

    v_pString = (char *)buffer;
    while (*v_pString != 0)
        MibWriteDebugByte((uint8_t)*v_pString++);
    return (rc);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
int mib_vsprintf(char *vpBuffer, char *format, ...)
{
    va_list ap;
    int rc;
    {
        va_start(ap, format);
        rc = simple_vsprintf(vpBuffer, format, ap);
        va_end(ap);
    }
    return (rc);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
/*
    3. %s 구현 시 주의사항 (STM8S 환경)
        버퍼 오버플로우 주의:
        위의 %s 구현은 목적지 버퍼(name[20])의 크기를 알지 못합니다. 만약 입력 문자열이 20자보다 길면 메모리 오염이 발생합니다.
        안전하게 사용하려면 입력받는 버퍼를 충분히 크게 잡거나, tiny_sscanf 내부에 길이 제한 로직을 추가해야 합니다.

        공백의 정의:
        isspace() 함수는 스페이스( ), 탭(\t), 줄바꿈(\n, \r)을 모두 공백으로 간주합니다. 따라서 어떤 종류의 화이트스페이스라도 구분자로 작동합니다.

        포인터 전달:
        %d, %x는 변수의 주소(&age)를 전달하지만, %s는 배열 이름 자체가 주소이므로 & 없이 name으로 전달합니다.
*/

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// 공백 문자를 건너뛰는 보조 함수
const char *skip_spaces(const char *str)
{
    while (*str && isspace((unsigned char)*str))
        str++;
    return str;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

// 16진수 문자를 숫자로 변환
int hex_to_int(char c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    return -1;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
// %d, %x, %c, %s 지원 경량형 sscanf
// int tiny_sscanf(const char *buf, const char *fmt, ...)
int mib_sscanf(const char *buf, const char *fmt, ...)
{
    unsigned int *x_ptr;
    unsigned int val;
    int h;
    char *s_ptr;
    char *c_ptr;
    int count = 0;
    int *d_ptr;
    int val_a;
    int sign;
    va_list args;
    va_start(args, fmt);
    while (*fmt && *buf)
    {
        if (*fmt == '%')
        {
            fmt++;
            switch (*fmt)
            {
            case 's':
            { // 문자열 처리 (공백 기준 분리)
                buf = skip_spaces(buf);
                s_ptr = va_arg(args, char *);
                // 공백이 아니고 문자열 끝이 아닐 때까지 복사
                while (*buf && !isspace((unsigned char)*buf))
                {
                    *s_ptr++ = *buf++;
                }
                *s_ptr = '\0'; // 문자열 끝 널(NULL) 처리
                count++;
                break;
            }
            case 'c':
            { // 문자 처리
                c_ptr = va_arg(args, char *);
                *c_ptr = *buf++;
                count++;
                break;
            }
            case 'd':
            { // 10진수 정수 처리
                buf = skip_spaces(buf);
                d_ptr = va_arg(args, int *);
                val_a = 0;
                sign = 1;
                if (*buf == '-')
                {
                    sign = -1;
                    buf++;
                }
                while (isdigit((unsigned char)*buf))
                {
                    val_a = val_a * 10 + (*buf++ - '0');
                }
                *d_ptr = val_a * sign;
                count++;
                break;
            }
            case 'x':
            { // 16진수 정수 처리
                buf = skip_spaces(buf);
                x_ptr = va_arg(args, unsigned int *);
                val = 0;
                if (buf[0] == '0' && (buf[1] == 'x' || buf[1] == 'X'))
                    buf += 2;
                while ((h = hex_to_int(*buf)) != -1)
                {
                    val = (val << 4) | h;
                    buf++;
                }
                *x_ptr = val;
                count++;
                break;
            }
            }
        }
        else if (isspace((unsigned char)*fmt))
        {
            buf = skip_spaces(buf);
        }
        else
        {
            if (*fmt == *buf)
                buf++;
        }
        fmt++;
    }
    va_end(args);
    return count;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#if 0
void main_sscanf(void) {
    // 입력 예시: "James 25 0x1A"
    const char* input = "James 25 0x1A";
    
    char name[20];
    int age;
    unsigned int code;

    // %s %d %x 순서대로 파싱
    int result = tiny_sscanf(input, "%s %d %x", name, &age, &code);

    if (result == 3) {
        // name = "James"
        // age = 25
        // code = 26 (0x1A)
    }

    while (1);
}
#endif
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
const char *get_filename_manual(const char *path)
{
    const char *last = path;
    const char *p = path;

    while (*p != '\0')
    {
        if (*p == '/' || *p == '\\')
        {
            last = p + 1;
        }
        p++;
    }
    return last;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------