/**
 ******************************************************************************
 * @file stm8s_mib_lcd1602.c
 * @brief
 * @author MYMEDIA Co., Ltd.
 * @version V1.0.0
 * @date 2023.1.6
 ******************************************************************************
 */
#include "stm8s.h"
#include "stm8s_mib_i2c.h"

#define LCD_ADDR 0x4E // 0x27(7비트 주소) << 1
#define PIN_RS (1 << 0)
#define PIN_EN (1 << 2)
#define BACKLIGHT (1 << 3)
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD1602_Write(uint8_t data);
void LCD_SendInternal(uint8_t data, uint8_t flags);
void LCD_SendCommand(uint8_t cmd);
void LCD_SendData(uint8_t data);
void LCD_Init(void);
void LCD_Print(char *str);
void LCD_SetCursor(uint8_t row, uint8_t col);
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// I2C 1바이트 전송 함수
void LCD1602_Write(uint8_t data)
{
  I2C->CR2 |= 0x01; // Start
  while (!(I2C->SR1 & 0x01))
    ;

  I2C->DR = LCD_ADDR;
  while (!(I2C->SR1 & 0x02))
    ;
  (void)I2C->SR3;

  I2C->DR = data;
  while (!(I2C->SR1 & 0x80))
    ;

  I2C->CR2 |= 0x02; // Stop
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_SendInternal(uint8_t data, uint8_t flags)
{
  uint8_t up = (data & 0xF0) | flags | BACKLIGHT;
  uint8_t lo = ((data << 4) & 0xF0) | flags | BACKLIGHT;
  volatile int i;

  // 상위 4비트 전송
  LCD1602_Write(up | PIN_EN);
  for (i = 0; i < 500; i++)
    ; // Enable 펄스 유지
  LCD1602_Write(up & ~PIN_EN);

  // 하위 4비트 전송
  LCD1602_Write(lo | PIN_EN);
  for (i = 0; i < 500; i++)
    ; // Enable 펄스 유지
  LCD1602_Write(lo & ~PIN_EN);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_SendCommand(uint8_t cmd)
{
  LCD_SendInternal(cmd, 0);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_SendData(uint8_t data)
{
  LCD_SendInternal(data, PIN_RS);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_Init(void)
{
  volatile int i;
  // 4비트 모드 초기화 시퀀스
  for (i = 0; i < 5000; i++)
    ;                    // 충분한 전원 안정화 대기
  LCD_SendCommand(0x33); // 8비트 모드 설정 시도
  LCD_SendCommand(0x32); // 4비트 모드로 전환
  LCD_SendCommand(0x28); // 2라인, 5x8 폰트
  LCD_SendCommand(0x0C); // Display ON, Cursor OFF
  LCD_SendCommand(0x06); // Entry Mode: Increment
  LCD_SendCommand(0x01); // Clear Display
  for (i = 0; i < 5000; i++)
    ; // 클리어 명령어 처리 대기
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_Print(char *str)
{
  while (*str)
  {
    LCD_SendData(*str++);
  }
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void LCD_SetCursor(uint8_t row, uint8_t col)
{
  uint8_t addr = (row == 0) ? (0x80 + col) : (0xC0 + col);
  LCD_SendCommand(addr);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief LCD 화면의 모든 내용을 지우고 커서를 홈(0,0) 위치로 이동합니다.
 */
void LCD_Clear(void)
{
  volatile int i;
  // 1. Clear Display 명령 전송 (명령어 코드: 0x01)
  LCD_SendCommand(0x01);
  // 2. 실행 대기 시간 (중요!)
  // LCD1602 데이터시트에 따르면 Clear 명령은 처리에 약 1.52ms가 소요됩니다.
  // 시스템 클럭(16MHz 기준)에 맞춰 약 2ms 정도의 여유 있는 딜레이를 줍니다.
  for (i = 0; i < 5000; i++)
    ; // 클리어 명령어 처리 대기
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
