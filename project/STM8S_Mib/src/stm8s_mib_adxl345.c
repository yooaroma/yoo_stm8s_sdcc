/**
 ******************************************************************************
 * @file stm8s_mib_pcf8591.c
 * @brief
 * @author MYMEDIA Co., Ltd.
 * @version V1.0.0
 * @date 2023.1.6
 ******************************************************************************
 */
#include "stm8s.h"
#include "stm8s_mib_i2c.h"
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
#define ADXL345_ADDR 0xA6    // 7비트 주소 0x53 << 1
#define REG_POWER_CTL 0x2D   // 전원 제어 (측정 모드 설정)
#define REG_DATA_FORMAT 0x31 // 데이터 형식 (범위 설정)
#define REG_DATAX0 0x32      // X축 데이터 시작 레지스터
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
void ADXL345_WriteReg(uint8_t reg, uint8_t val);
void ADXL345_ReadBurst(uint8_t reg, uint8_t *buf, uint8_t len);
void ADXL345_Init(void);
void ADXL345_GetXYZ(int16_t *x, int16_t *y, int16_t *z);
uint8_t ADXL345_ReadReg(uint8_t reg);
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// 특정 레지스터에 1바이트 쓰기
void ADXL345_WriteReg(uint8_t reg, uint8_t val)
{
  I2C_Start();
  I2C_SendAddress(ADXL345_ADDR);
  I2C_WriteByte(reg);
  I2C_WriteByte(val);
  I2C_Stop();
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// 여러 바이트 읽기 (가속도 데이터는 X,Y,Z 총 6바이트임)
void ADXL345_ReadBurst(uint8_t reg, uint8_t *buf, uint8_t len)
{
  uint8_t i;
  I2C_Start();
  I2C_SendAddress(ADXL345_ADDR);
  I2C_WriteByte(reg);

  I2C_Start();                          // Re-start
  I2C_SendAddress(ADXL345_ADDR | 0x01); // Read 모드

  for (i = 0; i < len; i++)
  {
    if (i == len - 1)
    {
      I2C->CR2 &= ~0x04; // 마지막 바이트 전 NACK 설정
      I2C_Stop();
    }
    while (!(I2C->SR1 & 0x40))
      ; // RXNE 대기
    buf[i] = I2C->DR;
  }
  I2C->CR2 |= 0x04; // ACK 다시 켜기
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// ADXL345 초기화
void ADXL345_Init(void)
{
  // 1. 데이터 형식 설정: +/- 4g 범위 설정
  ADXL345_WriteReg(REG_DATA_FORMAT, 0x01);

  // 2. 측정 모드 시작 (Power Control 레지스터의 Measure 비트를 1로)
  ADXL345_WriteReg(REG_POWER_CTL, 0x08);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// 가속도 값 읽기 함수
void ADXL345_GetXYZ(int16_t *x, int16_t *y, int16_t *z)
{
  uint8_t rawData[6];

  // X0부터 Z1까지 6바이트 연속 읽기
  ADXL345_ReadBurst(REG_DATAX0, rawData, 6);

  // 각 축당 2바이트씩 조합 (LSB, MSB 순서)
  *x = (int16_t)((rawData[1] << 8) | rawData[0]);
  *y = (int16_t)((rawData[3] << 8) | rawData[2]);
  *z = (int16_t)((rawData[5] << 8) | rawData[4]);
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * @brief I2C를 통해 ADXL345의 레지스터 1바이트를 읽어옵니다.
 * @param reg 읽고자 하는 레지스터 주소
 * @return 읽어온 8비트 데이터
 */
uint8_t ADXL345_ReadReg(uint8_t reg)
{
  uint8_t value = 0;

  // 1. Start Condition 전송
  I2C->CR2 |= 0x01; // START = 1
  while (!(I2C->SR1 & 0x01))
    ; // SB(Start Bit) 대기

  // 2. 장치 주소 전송 (Write 모드)
  I2C->DR = ADXL345_ADDR; // 0xA6
  while (!(I2C->SR1 & 0x02))
    ;             // ADDR 대기
  (void)I2C->SR3; // SR3 읽어서 ADDR 플래그 클리어

  // 3. 읽고 싶은 레지스터 주소 전송
  I2C->DR = reg;
  while (!(I2C->SR1 & 0x80))
    ; // TXE(Transmit Empty) 대기

  // 4. Re-Start Condition 전송 (읽기 모드로 전환)
  I2C->CR2 |= 0x01; // START = 1
  while (!(I2C->SR1 & 0x01))
    ; // SB 대기

  // 5. 장치 주소 전송 (Read 모드)
  I2C->DR = ADXL345_ADDR | 0x01; // 0xA7
  while (!(I2C->SR1 & 0x02))
    ; // ADDR 대기

  // --- 단일 바이트 읽기 핵심 로직 ---
  I2C->CR2 &= ~0x04; // ACK 비트 비활성화 (NACK 설정)
  (void)I2C->SR3;    // ADDR 플래그 클리어
  I2C->CR2 |= 0x02;  // STOP 비트 생성 (데이터 수신 전 예약)

  // 6. 데이터 수신 대기
  while (!(I2C->SR1 & 0x40))
    ;              // RXNE(Receive Not Empty) 대기
  value = I2C->DR; // 데이터 읽기

  // 7. 다음 통신을 위해 ACK 다시 활성화
  I2C->CR2 |= 0x04; // ACK = 1

  return value;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////